<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>TP3 | Web3D</title>
        <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
        <style>body{margin:0;overflow:hidden}</style>
    </head>
    <body>
        <!-- <a-scene>
            <a-assets>
                <img id="ground" src="./assets/textures/grass/Poliigon_GrassPatchyGround_4585_BaseColor.jpg">
            </a-assets>            
            <a-plan src="#ground" height="10" width="10" rotation="-90 0 0"></a-plan>
            <a-box position="0 1 -3" material="metalness:1; roughness:0.01;"></a-box>
            <a-sphere position="2 1 -4" material="metalness:1; roughness:0.025;"></a-sphere>
            La skybox est passée comme background
        </a-scene>-->
        <a-scene>
            
            <a-box position="-1 1 1" material="metalness:1; roughness:0.01;"  shadow="receive: true; cast: true"></a-box>
            <a-sphere position="1 1 0" material="metalness:1; roughness:0.025;" shadow="receive: true; cast: true"></a-sphere>

            <!-- La skybox est passée comme background -->
            <a-plane id="ground-plane" 
                src="./assets/textures/grass/Poliigon_GrassPatchyGround_4585_BaseColor.jpg" 
                height="10" width="10" rotation="-90 0 0" 
                shadow="receive: true; cast: false"
                normal-map="./assets/textures/grass/Poliigon_GrassPatchyGround_4585_Normal.png" normal-scale=".7"
                roughness-map="./assets/textures/grass/Poliigon_GrassPatchyGround_4585_Roughness.jpg"
                ambientOcclusion-map="./assets/textures/grass/Poliigon_GrassPatchyGround_4585_AmbientOcclusion.jpg"
            ></a-plane>
            <a-entity id="sun"
                    light="type: directional; castShadow: true; intensity: 2"
                    position="-1 3 -6">
            </a-entity>
            
        </a-scene>
    </body>
    <script>
        (function (THREE) {
            if (THREE.RGBELoader) return;
            function RGBELoader(manager) {
            this.manager = manager || THREE.DefaultLoadingManager;
            this.path = ''; this.dataType = THREE.UnsignedByteType;
            }
            RGBELoader.prototype.setDataType = function (t) { this.dataType = t; return this; };
            RGBELoader.prototype.setPath    = function (p) { this.path = p; return this; };
            RGBELoader.prototype.load = function (url, onLoad, onProgress, onError) {
            const loader = new THREE.FileLoader(this.manager);
            loader.setPath(this.path); loader.setResponseType('arraybuffer');
            loader.load(url, (buffer) => {
                try {
                const texData = parseRGBE(buffer, this.dataType);
                const tex = new THREE.DataTexture(texData.data, texData.width, texData.height,
                                                    THREE.RGBAFormat, this.dataType);
                tex.needsUpdate = true;
                tex.generateMipmaps = false;
                tex.magFilter = THREE.LinearFilter;
                tex.minFilter = THREE.LinearFilter;
                tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
                tex.mapping = THREE.EquirectangularReflectionMapping;
                tex.colorSpace = THREE.LinearSRGBColorSpace;
                if (onLoad) onLoad(tex);
                } catch (e) { onError ? onError(e) : console.error(e); }
            }, onProgress, onError);
            };
            function parseRGBE(buffer, dataType) {
            const bytes = new Uint8Array(buffer); let p = 0;
            function readLine(){ let s='',c; while(p<bytes.length && (c=bytes[p++])!==10) s+=String.fromCharCode(c); return s; }
            let line = readLine(); if (line.substr(0,2)!=='#?') throw new Error('Bad HDR header');
            while ((line = readLine()).length) {}
            line = readLine(); const m = /-Y\s+(\d+)\s+\+X\s+(\d+)/i.exec(line);
            if (!m) throw new Error('Bad HDR size'); const H = parseInt(m[1],10), W = parseInt(m[2],10);
            const out = (dataType===THREE.FloatType)? new Float32Array(W*H*4) : new Uint8Array(W*H*4);
            const scan = new Uint8Array(4*W);
            for (let y=0; y<H; y++){
                let a=bytes[p++], b=bytes[p++], c=bytes[p++], d=bytes[p++];
                if (a!==2 || b!==2) throw new Error('Unsupported HDR (non-RLE)');
                const scanW = (c<<8)+d; if (scanW!==W) throw new Error('Bad scanline width');
                for (let ch=0; ch<4; ch++){
                for (let x=0; x<W;){
                    const cnt=bytes[p++]; if (cnt>128){ const run=cnt-128, val=bytes[p++]; for(let k=0;k<run;k++) scan[ch*W + x++] = val; }
                    else { for(let k=0;k<cnt;k++) scan[ch*W + x++] = bytes[p++]; }
                }
                }
                for (let x=0; x<W; x++){
                const r=scan[x], g=scan[W+x], b2=scan[2*W+x], e=scan[3*W+x];
                const f = e ? Math.pow(2.0, e - 136) : 0.0; // 128+8
                const i = (y*W + x)*4;
                if (out instanceof Float32Array){ out[i]=r*f; out[i+1]=g*f; out[i+2]=b2*f; out[i+3]=1.0; }
                else { out[i]=Math.min(255, r*f*255); out[i+1]=Math.min(255, g*f*255); out[i+2]=Math.min(255, b2*f*255); out[i+3]=255; }
                }
            }
            return { data: out, width: W, height: H };
            }
            THREE.RGBELoader = RGBELoader;
        })(window.THREE);
    </script>
    <script>
        const ground = document.querySelector("#ground-plane");
        const groundTextures = {
            Albedo: "./assets/textures/grass/Poliigon_GrassPatchyGround_4585_BaseColor.jpg",
            AO: "./assets/textures/grass/Poliigon_GrassPatchyGround_4585_AmbientOcclusion.jpg",
            Normal: "./assets/textures/grass/Poliigon_GrassPatchyGround_4585_Normal.jpg",
            Roughness: "./assets/textures/grass/Poliigon_GrassPatchyGround_4585_Roughness.jpg"
        }

        /*ground.addEventListener('loaded', e => {
            ground.setAttribute("normal-map") = groundTextures.Normal.value;
            ground.setAttribute("roughness-map") = groundTextures.Roughness.value;
        });*/
    </script>
    <script>
        let hdrTexture = null;

        /*AFRAME.registerComponent("hdr-skybox", {
            schema: {
                exposure: {type: "number", default: 1.0}
            },
            init: function () {
                const sceneEl = this.el.sceneEl;
                const threeScene = sceneEl.object3D;
                const renderer = sceneEl.renderer;

                const loader = new THREE.RGBELoader();
                loader.setDataType(THREE.UnsignedByteType);
                loader.load("./assets/hdri/spaichingen_hill_2k.hdr", (texture) => {
                    const pmremGen = new THREE.PMREMGenerator(renderer);
                    pmremGen.compileEquirectangularShader();
                    const envMap = pmremGen.fromEquirectangular(texture).texture;
                    hdrTexture = texture;

                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.toneMappingExposure = this.data.exposure;
                    renderer.outputColorSpace = THREE.SRGBColorSpace;

                    applyEnvRotation(225, 180, 0);

                    threeScene.environment = envMap;
                    threeScene.background  = texture;

                    texture.dispose();
                    pmremGen.dispose();
                });
            }
        });*/

        const sceneEl = document.querySelector('a-scene');
        sceneEl.addEventListener('render-target-loaded', e => {
            const r = e.target.renderer;
            r.outputColorSpace = THREE.SRGBColorSpace;
            r.toneMapping = THREE.NeutralToneMapping;
            r.toneMappingExposure = 1.0;
        });
        sceneEl.addEventListener('loaded', () => {
            const r = sceneEl.renderer;
            r.shadowMap.enabled = true;
            r.shadowMap.type = THREE.PCFSoftShadowMap;
            r.toneMappingExposure = 1.3;

            const sun = document.querySelector('#sun').getObject3D('light');
            if (sun) {
                sun.shadow.mapSize.set(1024, 1024);
                sun.shadow.bias = -0.0005;
                sun.shadow.camera.near = 0.1;
                sun.shadow.camera.far  = 20;
                sun.shadow.camera.left = -5; sun.shadow.camera.right = 5;
                sun.shadow.camera.top = 5;  sun.shadow.camera.bottom = -5;
            }
        });

        function buildEnvFromHDRRotated(renderer, hdrTex, {yaw=0, pitch=0, roll=0} = {}) {
            const pmrem = new THREE.PMREMGenerator(renderer);
            const envScene = new THREE.Scene();
            const sky = new THREE.Mesh(
            new THREE.SphereGeometry(1, 64, 32),
            new THREE.MeshBasicMaterial({ map: hdrTex, side: THREE.BackSide, toneMapped: false })
            );
            sky.rotation.set(
            THREE.MathUtils.degToRad(pitch), // X
            THREE.MathUtils.degToRad(yaw),   // Y
            THREE.MathUtils.degToRad(roll)   // Z
            );
            envScene.add(sky);
            const { texture } = pmrem.fromScene(envScene, 0.0);
            pmrem.dispose();
            return texture;
        }

        const HDR_URL = './assets/hdri/spaichingen_hill_2k.hdr';
        const sky = document.querySelector("#hdr-skybox");

        sceneEl.addEventListener('loaded', () => {
            const renderer = sceneEl.renderer;
            new THREE.RGBELoader()
            .setDataType(THREE.UnsignedByteType)
            .load(HDR_URL, (tex) => {
                hdrTexture = tex;
                applyEnvRotation(225, 180, 0);
            });
        });

        function applyEnvRotation(yawDeg, pitchDeg, rollDeg){
            if (!hdrTexture) return;
            const renderer = sceneEl.renderer;
            const envMap = buildEnvFromHDRRotated(renderer, hdrTexture, {
            yaw: yawDeg, pitch: pitchDeg, roll: rollDeg
            });
            const threeScene = sceneEl.object3D;
            threeScene.environment = envMap;
            threeScene.background = envMap;
        }

    </script>
</html>