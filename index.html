<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>TP3 | Web3D</title>
        <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
        <script src="https://unpkg.com/@c-frame/aframe-physics-system@4.2.2/dist/aframe-physics-system.min.js"></script>
        <script src="./assets/scripts/look-control.js"></script>
        <style>body{margin:0;overflow:hidden}</style>
    </head>
    <body>
        <a-scene physics="debug: true">

            <a-plane id="ground-plane" 
                class="ground"
                src="./assets/textures/grass/Poliigon_GrassPatchyGround_4585_BaseColor.jpg" 
                height="100" width="100" rotation="-90 0 0" 
                repeat="50 50" normal-texture-repeat="50 50" ambient-occlusion-texture-repeat="50 50" roughness-texture-repeat="50 50" metalness-texture-repeat="50 50"
                shadow="receive: true; cast: false"
                normal-map="./assets/textures/grass/Poliigon_GrassPatchyGround_4585_Normal.png" normal-scale="2 2"
                roughness="1" roughness-map="./assets/textures/grass/Poliigon_GrassPatchyGround_4585_Roughness.jpg"
                ambientOcclusion-map="./assets/textures/grass/Poliigon_GrassPatchyGround_4585_AmbientOcclusion.jpg" ambientOcclusion-intensity="1"
                metalness-map="./assets/textures/grass/Poliigon_GrassPatchyGround_4585_Metallic.jpg"
                body="type: static; shape: auto;"
            ></a-plane>

            <!--<a-box id="deepGroundBox" class="ground" position="0 -0.51 0" depth="100" height="1" width="100"
                color="#00000" shadow="cast: true; receive: true"
                static-body="offset: 0.01 0 0;"></a-box>-->

            <a-box position="5 0.5 -5" depth="1" height="1" width="1"
                color="#ffffff" shadow="cast: true; receive: true"
                material="metalness: 1; roughness: 0"
                class="ground"
                static-body="shape: box;"></a-box>
            
            <a-entity id="player-rig"
                move-controls="speed: .3; jumpSpeed: 10; rayLen: 0.7; groundEps: 0.05"
                position="0 2 0"
                rotation="0 0 0" 
                body="type: dynamic; shape: none; mass: 15 ; linearDamping: 0.75; angularDamping: .8; material: playerMaterial;"
                shape="shape: cylinder; 
                       height: 1.67;
                       radiusTop: 0.25;
                       radiusBottom: 0.25; 
                       offset: 0 0 0;"
                log="loaded player-rig">
                <a-gltf-model id="player-model" 
                            src="./assets/models/ben_10_alien_force_ben_tennyson.glb" 
                            scale="0.1 0.1 0.1"
                            rotation="0 180 0"
                            position="0 -0.835 0"
                            shadow="cast: true; receive: true" player-model>
                    <a-entity id="ground-raycaster"
                            raycaster="objects: .ground; showLine:true; direction: 0 -1 0;"
                            position="0 -1 0">
                    </a-entity>
                </a-gltf-model>
                <a-entity id="look-rig">
                    <a-entity id="camera-rig" position="0 0.665 0" rotation="0 0 0"
                        look-controls="pointerLockEnabled: true; physicalRotation: true;"
                        dynamic-body="shape: auto; mass: 0; type: kinematic;">
                        <a-camera wasd-controls-enabled="false" rotation="0 0 0" position="-0.6 0 .65" 
                                    camera="fov: 75; near: 0.1; far: 1000; active: true">
                            <a-entity cursor="fuse: false; rayOrigin: mouse"
                                    position="0 0 -0.1" 
                                    geometry="primitive: ring; radiusInner: 0.0005; radiusOuter: 0.001" 
                                    material="color: black; shader: flat">
                            </a-entity>
                        </a-camera>
                    </a-entity>
                </a-entity>
            </a-entity>

            <a-entity id="sun"
                    light="type: directional; castShadow: true; intensity: 2"
                    position="-10 30 -60">
            </a-entity>
            <!-- La skybox est passée comme background -->
            
        </a-scene>
    </body>
    <script>
        const camera = document.querySelector('#player-rig a-camera');
        const cameraRig = document.querySelector('#camera-rig');
        const player = document.querySelector('#player-rig');
        const groundRaycaster = document.querySelector('#ground-raycaster');
        const model = document.querySelector('#player-model');
        const groundPlane = document.querySelector('#ground-plane');
        const lookControls = camera.components['look-controls'];
        const deepGroundBox = document.querySelector('#deepGroundBox');

        AFRAME.registerComponent('player-model', {
            init: function () {
                const rotation = cameraRig.getAttribute('rotation');
                model.setAttribute('rotation', `0 ${rotation.y + 180} 0`);
            },
            tick: function (time, deltaTime) {
                const rotation = cameraRig.getAttribute('rotation');
                if (rotation.x > 45) cameraRig.setAttribute('rotation', `45 ${rotation.y} ${rotation.z}`);
                if (rotation.x < -45) cameraRig.setAttribute('rotation', `-45 ${rotation.y} ${rotation.z}`);
                model.setAttribute('rotation', `0 ${rotation.y + 180} 0`);
            }
        });

        AFRAME.registerComponent('log', {
            schema: {type: 'string'},
            init: function () { console.log(this.data); },
            tick: function (time, deltaTime) {
                //console.log("position:",this.el.getAttribute('position'), "rotation:",this.el.getAttribute('rotation'));
            }
        });

        player.addEventListener('body-loaded', () => {
            const body = player.body;
            body.angularFactor.set(0, 1, 0); // No rotation
            
            const noFriction = new CANNON.Material("playerMaterial");
            noFriction.friction = 0.0;
            noFriction.restitution = 0.0;
            
            body.material = noFriction;

            body.mass = 20;
        });

        groundPlane.addEventListener('body-loaded', () => {
            const body = groundPlane.body;
            const shape = body.shapes[0];
            const groundMaterial = new CANNON.Material("groundMaterial");
            groundMaterial.friction = 0.0;
            groundMaterial.restitution = 0.0;
            body.material = groundMaterial;

            const contactMaterial = new CANNON.ContactMaterial(
                groundMaterial,
                player.body.material,
                {
                    friction: 0.0,
                    restitution: 0.0
                }
            );
            groundPlane.body.world.addContactMaterial(contactMaterial);
            player.body.updateMassProperties();
            console.log(player.body.mass);
        });

        AFRAME.registerComponent('move-controls', {
            schema: {
                speed: {type: 'number', default: 5},
                jumpSpeed: {type: 'number', default: 5},
                jumpCooldown: {type: 'number', default: 500},
                rayLen: {type: 'number', default: 0.7},
                gravity: {type: 'number', default: 9.81},
                groundEps: {type: 'number', default: 0.05}
            },
            init: function () {
                this.keys = {};
                window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
                window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);

                this.force = new THREE.Vector3();

                this.forward = new THREE.Vector3();
                this.right = new THREE.Vector3();
                this.up = new THREE.Vector3(0, 1, 0);

                this.forwardForce = new THREE.Vector3();
                this.rightForce = new THREE.Vector3();
                this.upForce = new THREE.Vector3();

                this.isTouchingGround = true;
                this.isJumping = false;
                this.jumpTimer = 0;

                this.raycaster = groundRaycaster.components.raycaster.raycaster;
                this.groundMeshes = [];
                const collectGroundMeshes = () => { 
                    this.groundMeshes.length = 0; 
                    const ents = this.el.sceneEl.querySelectorAll('.ground'); 
                    ents.forEach(e => e.object3D && e.object3D.traverse(o => { if (o.isMesh) this.groundMeshes.push(o); })); 
                };
                if (this.el.sceneEl.hasLoaded) collectGroundMeshes(); else this.el.sceneEl.addEventListener('loaded', collectGroundMeshes);
                const refreshIfGround = (e)=>{ 
                    const n=e.detail&&e.detail.el; 
                    if(n && n.classList && n.classList.contains('ground')) collectGroundMeshes(); 
                }; 
                this.el.sceneEl.addEventListener('child-attached', refreshIfGround); 
                this.el.sceneEl.addEventListener('child-detached', refreshIfGround);

                this.el.addEventListener('body-loaded', () => {
                    this.body = this.el.body;
                });
            },

            tick: function (time, deltaTime) {
                const el = this.el;
                const position = el.getAttribute('position');
                const rotation = el.getAttribute('rotation');
                const deltaMove = this.data.speed;

                camera.object3D.getWorldDirection(this.forward);
                this.forward.y = 0; 
                this.forward.normalize();
                this.right.copy(this.forward).cross(new THREE.Vector3(0, 1, 0)).normalize();

                // Movement Velocity
                this.force.set(0, 0, 0);
                if (this.keys['z']) this.force.addScaledVector(this.forward, -deltaMove);
                if (this.keys['s']) this.force.addScaledVector(this.forward, deltaMove);
                if (this.keys['q']) this.force.addScaledVector(this.right, deltaMove);
                if (this.keys['d']) this.force.addScaledVector(this.right, -deltaMove);

                // Ground Detection
                const rayPos = new THREE.Vector3();
                this.el.object3D.getWorldPosition(rayPos);
                const dir = new THREE.Vector3(0, -1, 0);
                this.raycaster.set(rayPos, dir);
                this.raycaster.near = 0;
                this.raycaster.far = this.data.rayLen + 0.01;
                const hits = this.groundMeshes.length ? this.raycaster.intersectObjects(this.groundMeshes, true) : [];
                const isSelfOrDescendant = (obj)=>{ 
                    for(let o=obj;o;o=o.parent) if(o===this.el.object3D) return true; return false; 
                };
                this.isTouchingGround = hits.some(h =>
                    !isSelfOrDescendant(h.object) &&
                    h.distance <= (this.data.rayLen + this.data.groundEps)
                );
                console.log('Hits:', hits.map(h => !this.el.object3D.children.includes(h.object)));
                console.log('Ray Far:', this.raycaster.far, ' | ε:', this.data.groundEps);
                console.log('IsTouchingGround:', this.isTouchingGround);


                // Jump Detection
                const jumpDown = !!(this.keys[' '] || this.keys['space']);
                const justPressedJump = jumpDown && !this.wasJumpDown;
                this.wasJumpDown = jumpDown;
                /*if (this.keys[' ']) {
                    if (this.isTouchingGround && !this.isJumping) {
                        this.isTouchingGround = false;
                        position.y += 5 * (deltaTime / 1000);
                        el.setAttribute('position', position);
                        this.isJumping = true;
                    }
                }*/

                // Jump Physics
                if (justPressedJump && this.isTouchingGround) {
                    this.body.velocity.x += this.force.x;
                    this.body.velocity.y += this.data.jumpSpeed;
                    this.body.velocity.z += this.force.z;
                } else {
                    this.body.velocity.x += this.force.x;
                    this.body.velocity.z += this.force.z;
                }
                /*if (this.isJumping) {
                    this.jumpTimer += deltaTime;
                    if (this.jumpTimer >= this.data.jumpCooldown) {
                        this.isTouchingGround = false;
                        this.isJumping = false;
                        this.jumpTimer = 0;
                        console.log("Jump ended");
                    } else {
                        position.y += this.data.jumpSpeed * (-((1 - (this.jumpTimer)/this.data.jumpCooldown)**2) + 1) * (deltaTime / 1000);
                        this.isTouchingGround = false;
                    }
                }*/

                // Gravity
                /*if (!this.isTouchingGround && !this.isJumping) {
                    position.y -= this.data.gravity * (deltaTime / 1000);
                    if (position.y < 0) {
                        position.y = 0;
                        this.isTouchingGround = true;
                    }
                    console.log("gravity applied, y =", position.y);
                }*/

                /*el.setAttribute('position', position);*/

                console.log("isTouchingGround:", this.isTouchingGround, "postion.y:", position.y, "jumpPressing:", justPressedJump);
            }
        });

    </script>
    <script>

    </script>
    <script>
        (function (THREE) {
            if (THREE.RGBELoader) return;
            function RGBELoader(manager) {
            this.manager = manager || THREE.DefaultLoadingManager;
            this.path = ''; this.dataType = THREE.UnsignedByteType;
            }
            RGBELoader.prototype.setDataType = function (t) { this.dataType = t; return this; };
            RGBELoader.prototype.setPath    = function (p) { this.path = p; return this; };
            RGBELoader.prototype.load = function (url, onLoad, onProgress, onError) {
            const loader = new THREE.FileLoader(this.manager);
            loader.setPath(this.path); loader.setResponseType('arraybuffer');
            loader.load(url, (buffer) => {
                try {
                const texData = parseRGBE(buffer, this.dataType);
                const tex = new THREE.DataTexture(texData.data, texData.width, texData.height,
                                                    THREE.RGBAFormat, this.dataType);
                tex.needsUpdate = true;
                tex.generateMipmaps = false;
                tex.magFilter = THREE.LinearFilter;
                tex.minFilter = THREE.LinearFilter;
                tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
                tex.mapping = THREE.EquirectangularReflectionMapping;
                tex.colorSpace = THREE.LinearSRGBColorSpace;
                if (onLoad) onLoad(tex);
                } catch (e) { onError ? onError(e) : console.error(e); }
            }, onProgress, onError);
            };
            function parseRGBE(buffer, dataType) {
            const bytes = new Uint8Array(buffer); let p = 0;
            function readLine(){ let s='',c; while(p<bytes.length && (c=bytes[p++])!==10) s+=String.fromCharCode(c); return s; }
            let line = readLine(); if (line.substr(0,2)!=='#?') throw new Error('Bad HDR header');
            while ((line = readLine()).length) {}
            line = readLine(); const m = /-Y\s+(\d+)\s+\+X\s+(\d+)/i.exec(line);
            if (!m) throw new Error('Bad HDR size'); const H = parseInt(m[1],10), W = parseInt(m[2],10);
            const out = (dataType===THREE.FloatType)? new Float32Array(W*H*4) : new Uint8Array(W*H*4);
            const scan = new Uint8Array(4*W);
            for (let y=0; y<H; y++){
                let a=bytes[p++], b=bytes[p++], c=bytes[p++], d=bytes[p++];
                if (a!==2 || b!==2) throw new Error('Unsupported HDR (non-RLE)');
                const scanW = (c<<8)+d; if (scanW!==W) throw new Error('Bad scanline width');
                for (let ch=0; ch<4; ch++){
                for (let x=0; x<W;){
                    const cnt=bytes[p++]; if (cnt>128){ const run=cnt-128, val=bytes[p++]; for(let k=0;k<run;k++) scan[ch*W + x++] = val; }
                    else { for(let k=0;k<cnt;k++) scan[ch*W + x++] = bytes[p++]; }
                }
                }
                for (let x=0; x<W; x++){
                const r=scan[x], g=scan[W+x], b2=scan[2*W+x], e=scan[3*W+x];
                const f = e ? Math.pow(2.0, e - 136) : 0.0; // 128+8
                const i = (y*W + x)*4;
                if (out instanceof Float32Array){ out[i]=r*f; out[i+1]=g*f; out[i+2]=b2*f; out[i+3]=1.0; }
                else { out[i]=Math.min(255, r*f*255); out[i+1]=Math.min(255, g*f*255); out[i+2]=Math.min(255, b2*f*255); out[i+3]=255; }
                }
            }
            return { data: out, width: W, height: H };
            }
            THREE.RGBELoader = RGBELoader;
        })(window.THREE);
    </script>
    <script>
        let hdrTexture = null;

        /*AFRAME.registerComponent("hdr-skybox", {
            schema: {
                exposure: {type: "number", default: 1.0}
            },
            init: function () {
                const sceneEl = this.el.sceneEl;
                const threeScene = sceneEl.object3D;
                const renderer = sceneEl.renderer;

                const loader = new THREE.RGBELoader();
                loader.setDataType(THREE.UnsignedByteType);
                loader.load("./assets/hdri/spaichingen_hill_2k.hdr", (texture) => {
                    const pmremGen = new THREE.PMREMGenerator(renderer);
                    pmremGen.compileEquirectangularShader();
                    const envMap = pmremGen.fromEquirectangular(texture).texture;
                    hdrTexture = texture;

                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.toneMappingExposure = this.data.exposure;
                    renderer.outputColorSpace = THREE.SRGBColorSpace;

                    applyEnvRotation(225, 180, 0);

                    threeScene.environment = envMap;
                    threeScene.background  = texture;

                    texture.dispose();
                    pmremGen.dispose();
                });
            }
        });*/

        const sceneEl = document.querySelector('a-scene');
        sceneEl.addEventListener('render-target-loaded', e => {
            const r = e.target.renderer;
            r.outputColorSpace = THREE.SRGBColorSpace;
            r.toneMapping = THREE.NeutralToneMapping;
            r.toneMappingExposure = 1.0;
        });
        sceneEl.addEventListener('loaded', () => {
            const r = sceneEl.renderer;
            r.shadowMap.enabled = true;
            r.shadowMap.type = THREE.PCFSoftShadowMap;
            r.toneMappingExposure = 1.3;

            const sun = document.querySelector('#sun').getObject3D('light');
            if (sun) {
                sun.shadow.mapSize.set(1024, 1024);
                sun.shadow.bias = -0.0005;
                sun.shadow.camera.near = 7;
                sun.shadow.camera.far  = 115;
                sun.shadow.camera.left = -60; sun.shadow.camera.right = 60;
                sun.shadow.camera.top = 60;  sun.shadow.camera.bottom = -60;
            }
        });

        function buildEnvFromHDRRotated(renderer, hdrTex, {yaw=0, pitch=0, roll=0} = {}) {
            const pmrem = new THREE.PMREMGenerator(renderer);
            const envScene = new THREE.Scene();
            const sky = new THREE.Mesh(
            new THREE.SphereGeometry(1, 64, 32),
            new THREE.MeshBasicMaterial({ map: hdrTex, side: THREE.BackSide, toneMapped: false })
            );
            sky.rotation.set(
            THREE.MathUtils.degToRad(pitch), // X
            THREE.MathUtils.degToRad(yaw),   // Y
            THREE.MathUtils.degToRad(roll)   // Z
            );
            envScene.add(sky);
            const { texture } = pmrem.fromScene(envScene, 0.0);
            pmrem.dispose();
            return texture;
        }

        const HDR_URL = './assets/hdri/spaichingen_hill_2k.hdr';
        const sky = document.querySelector("#hdr-skybox");

        sceneEl.addEventListener('loaded', () => {
            const renderer = sceneEl.renderer;
            new THREE.RGBELoader()
            .setDataType(THREE.UnsignedByteType)
            .load(HDR_URL, (tex) => {
                hdrTexture = tex;
                applyEnvRotation(225, 180, 0);
            });
        });

        function applyEnvRotation(yawDeg, pitchDeg, rollDeg){
            if (!hdrTexture) return;
            const renderer = sceneEl.renderer;
            const envMap = buildEnvFromHDRRotated(renderer, hdrTexture, {
            yaw: yawDeg, pitch: pitchDeg, roll: rollDeg
            });
            const threeScene = sceneEl.object3D;
            threeScene.environment = envMap;
            threeScene.background = envMap;
        }

    </script>
</html>