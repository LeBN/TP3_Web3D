<!DOCTYPE html>
<html>
    <head>
        <meta charset="utf-8" />
        <title>TP3 | Web3D</title>
        <script src="https://aframe.io/releases/1.7.0/aframe.min.js"></script>
        <script src="https://unpkg.com/@c-frame/aframe-physics-system@4.2.2/dist/aframe-physics-system.min.js"></script>
        <style>body{margin:0;overflow:hidden}</style>
    </head>
    <body>
        <a-scene physics="debug: false">
            <a-entity id="player-rig"
                look-controls="pointerLockEnabled: true"
                move-controls="speed: 7; jumpSpeed: 20; jumpCooldown: 200; gravity: 9.81"
                position="0 0 0"
                rotation="0 0 0" 
                dynamic-body="primitive: sphere; mass: 50; linearDamping: 0.2">
                <a-gltf-model id="player-model" 
                            src="./assets/models/ben_10_alien_force_ben_tennyson.glb" 
                            scale="0.5 0.5 0.5"
                            rotation="0 180 0"
                            shadow="cast: true; receive: true">
                </a-gltf-model>
                <a-entity id="camera-rig" position="-0.6 1.5 0" rotation="0 0 0">
                    <a-camera wasd-controls-enabled="false" rotation="0 0 0" position="0 0 .65" 
                                camera="fov: 75; near: 0.1; far: 1000; active: true">
                        <a-entity cursor="fuse: false; rayOrigin: mouse"
                                position="0 0 -1" 
                                geometry="primitive: ring; radiusInner: 0.005; radiusOuter: 0.01" 
                                material="color: black; shader: flat">
                        </a-entity>
                    </a-camera>
                </a-entity>
            </a-entity>

            <a-plane id="ground-plane" 
                src="./assets/textures/grass/Poliigon_GrassPatchyGround_4585_BaseColor.jpg" 
                height="100" width="100" rotation="-90 0 0" 
                repeat="50 50" normal-texture-repeat="50 50" ambient-occlusion-texture-repeat="50 50" roughness-texture-repeat="50 50" metalness-texture-repeat="50 50"
                shadow="receive: true; cast: false"
                normal-map="./assets/textures/grass/Poliigon_GrassPatchyGround_4585_Normal.png" normal-scale="2 2"
                roughness="1" roughness-map="./assets/textures/grass/Poliigon_GrassPatchyGround_4585_Roughness.jpg"
                ambientOcclusion-map="./assets/textures/grass/Poliigon_GrassPatchyGround_4585_AmbientOcclusion.jpg" ambientOcclusion-intensity="1"
                metalness-map="./assets/textures/grass/Poliigon_GrassPatchyGround_4585_Metallic.jpg"
                static-body
            ></a-plane>

            <a-entity id="sun"
                    light="type: directional; castShadow: true; intensity: 2"
                    position="-1 3 -6">
            </a-entity>
            <!-- La skybox est passÃ©e comme background -->
            
        </a-scene>
    </body>
    <script>
        const ground = document.querySelector("#ground-plane");
        const groundTextures = {
            Albedo: "./assets/textures/grass/Poliigon_GrassPatchyGround_4585_BaseColor.jpg",
            AO: "./assets/textures/grass/Poliigon_GrassPatchyGround_4585_AmbientOcclusion.jpg",
            Normal: "./assets/textures/grass/Poliigon_GrassPatchyGround_4585_Normal.jpg",
            Roughness: "./assets/textures/grass/Poliigon_GrassPatchyGround_4585_Roughness.jpg"
        }

        /*ground.addEventListener('loaded', e => {
            ground.setAttribute("normal-map") = groundTextures.Normal.value;
            ground.setAttribute("roughness-map") = groundTextures.Roughness.value;
        });*/
    </script>
    <script>
        const camera = document.querySelector('#player-rig a-camera');
        const player = document.querySelector('#player-rig');
        const lookControls = camera.components['look-controls'];

        AFRAME.registerComponent('log', {
            schema: {type: 'string'},
            init: function () { console.log(this.data); }
        });

        player.addEventListener('body-loaded', () => {
            const body = player.body;
            body.angularFactor.set(0, 1, 0);
        });

        AFRAME.registerComponent('move-controls', {
            schema: {
                speed: {type: 'number', default: 5},
                jumpSpeed: {type: 'number', default: 5},
                jumpCooldown: {type: 'number', default: 500},
                gravity: {type: 'number', default: 9.81}
            },
            init: function () {
                this.keys = {};
                window.addEventListener('keydown', e => this.keys[e.key.toLowerCase()] = true);
                window.addEventListener('keyup', e => this.keys[e.key.toLowerCase()] = false);

                this.tmp = new THREE.Vector3();

                this.forward = new THREE.Vector3();
                this.right = new THREE.Vector3();
                this.up = new THREE.Vector3(0, 1, 0);

                this.forwardForce = new THREE.Vector3();
                this.rightForce = new THREE.Vector3();
                this.upForce = new THREE.Vector3();

                this.isTouchingGround = true;
                this.isJumping = false;
                this.jumpTimer = 0;

                this.raycaster = new THREE.Raycaster();

                this.el.addEventListener('body-loaded', () => {
                    this.body = this.el.body;
                });
            },

            tick: function (time, deltaTime) {
                const el = this.el;
                const position = el.getAttribute('position');
                const rotation = el.getAttribute('rotation');
                const deltaMove = (this.data.speed * deltaTime) / 1000;

                camera.object3D.getWorldDirection(this.forward);
                this.forward.y = 0; 
                this.forward.normalize();
                this.right.copy(this.forward).cross(new THREE.Vector3(0, 1, 0)).normalize();

                // Movement Velocity
                this.tmp.set(0, 0, 0);
                if (this.keys['z']) tmp.addScaledVector(this.forward, -deltaMove);
                if (this.keys['s']) tmp.addScaledVector(this.forward, deltaMove);
                if (this.keys['q']) tmp.addScaledVector(this.right, deltaMove);
                if (this.keys['d']) tmp.addScaledVector(this.right, -deltaMove);

                const pos = this.el.object3D.position.clone();
                this.raycaster.set(pos, new THREE.Vector3(0,-1,0), 0, this.data.rayLen + 0.01);
                const hits = this.raycaster.intersectObjects(this.el.sceneEl.object3D.children, true);

                // Jump Start
                const jumpDown = !!(this.keys[' '] || this.keys['space']);
                const justPressedJump = jumpDown && !this.wasJumpDown;
                this.wasJumpDown = jumpDown;
                /*if (this.keys[' ']) {
                    if (this.isTouchingGround && !this.isJumping) {
                        this.isTouchingGround = false;
                        position.y += 5 * (deltaTime / 1000);
                        el.setAttribute('position', position);
                        this.isJumping = true;
                    }
                }*/

                // Jump Physics
                if (this.isJumping) {
                    this.jumpTimer += deltaTime;
                    if (this.jumpTimer >= this.data.jumpCooldown) {
                        this.isTouchingGround = false;
                        this.isJumping = false;
                        this.jumpTimer = 0;
                        console.log("Jump ended");
                    } else {
                        position.y += this.data.jumpSpeed * (-((1 - (this.jumpTimer)/this.data.jumpCooldown)**2) + 1) * (deltaTime / 1000);
                        this.isTouchingGround = false;
                    }
                }

                // Gravity
                if (!this.isTouchingGround && !this.isJumping) {
                    position.y -= this.data.gravity * (deltaTime / 1000);
                    if (position.y < 0) {
                        position.y = 0;
                        this.isTouchingGround = true;
                    }
                    console.log("gravity applied, y =", position.y);
                }

                el.setAttribute('position', position);

                console.log("isTouchingGround:", this.isTouchingGround, "isJumping:", this.isJumping, "jumpTimer:", this.jumpTimer);
            }
        });

    </script>
    <script>
        (function (THREE) {
            if (THREE.RGBELoader) return;
            function RGBELoader(manager) {
            this.manager = manager || THREE.DefaultLoadingManager;
            this.path = ''; this.dataType = THREE.UnsignedByteType;
            }
            RGBELoader.prototype.setDataType = function (t) { this.dataType = t; return this; };
            RGBELoader.prototype.setPath    = function (p) { this.path = p; return this; };
            RGBELoader.prototype.load = function (url, onLoad, onProgress, onError) {
            const loader = new THREE.FileLoader(this.manager);
            loader.setPath(this.path); loader.setResponseType('arraybuffer');
            loader.load(url, (buffer) => {
                try {
                const texData = parseRGBE(buffer, this.dataType);
                const tex = new THREE.DataTexture(texData.data, texData.width, texData.height,
                                                    THREE.RGBAFormat, this.dataType);
                tex.needsUpdate = true;
                tex.generateMipmaps = false;
                tex.magFilter = THREE.LinearFilter;
                tex.minFilter = THREE.LinearFilter;
                tex.wrapS = tex.wrapT = THREE.ClampToEdgeWrapping;
                tex.mapping = THREE.EquirectangularReflectionMapping;
                tex.colorSpace = THREE.LinearSRGBColorSpace;
                if (onLoad) onLoad(tex);
                } catch (e) { onError ? onError(e) : console.error(e); }
            }, onProgress, onError);
            };
            function parseRGBE(buffer, dataType) {
            const bytes = new Uint8Array(buffer); let p = 0;
            function readLine(){ let s='',c; while(p<bytes.length && (c=bytes[p++])!==10) s+=String.fromCharCode(c); return s; }
            let line = readLine(); if (line.substr(0,2)!=='#?') throw new Error('Bad HDR header');
            while ((line = readLine()).length) {}
            line = readLine(); const m = /-Y\s+(\d+)\s+\+X\s+(\d+)/i.exec(line);
            if (!m) throw new Error('Bad HDR size'); const H = parseInt(m[1],10), W = parseInt(m[2],10);
            const out = (dataType===THREE.FloatType)? new Float32Array(W*H*4) : new Uint8Array(W*H*4);
            const scan = new Uint8Array(4*W);
            for (let y=0; y<H; y++){
                let a=bytes[p++], b=bytes[p++], c=bytes[p++], d=bytes[p++];
                if (a!==2 || b!==2) throw new Error('Unsupported HDR (non-RLE)');
                const scanW = (c<<8)+d; if (scanW!==W) throw new Error('Bad scanline width');
                for (let ch=0; ch<4; ch++){
                for (let x=0; x<W;){
                    const cnt=bytes[p++]; if (cnt>128){ const run=cnt-128, val=bytes[p++]; for(let k=0;k<run;k++) scan[ch*W + x++] = val; }
                    else { for(let k=0;k<cnt;k++) scan[ch*W + x++] = bytes[p++]; }
                }
                }
                for (let x=0; x<W; x++){
                const r=scan[x], g=scan[W+x], b2=scan[2*W+x], e=scan[3*W+x];
                const f = e ? Math.pow(2.0, e - 136) : 0.0; // 128+8
                const i = (y*W + x)*4;
                if (out instanceof Float32Array){ out[i]=r*f; out[i+1]=g*f; out[i+2]=b2*f; out[i+3]=1.0; }
                else { out[i]=Math.min(255, r*f*255); out[i+1]=Math.min(255, g*f*255); out[i+2]=Math.min(255, b2*f*255); out[i+3]=255; }
                }
            }
            return { data: out, width: W, height: H };
            }
            THREE.RGBELoader = RGBELoader;
        })(window.THREE);
    </script>
    <script>
        let hdrTexture = null;

        /*AFRAME.registerComponent("hdr-skybox", {
            schema: {
                exposure: {type: "number", default: 1.0}
            },
            init: function () {
                const sceneEl = this.el.sceneEl;
                const threeScene = sceneEl.object3D;
                const renderer = sceneEl.renderer;

                const loader = new THREE.RGBELoader();
                loader.setDataType(THREE.UnsignedByteType);
                loader.load("./assets/hdri/spaichingen_hill_2k.hdr", (texture) => {
                    const pmremGen = new THREE.PMREMGenerator(renderer);
                    pmremGen.compileEquirectangularShader();
                    const envMap = pmremGen.fromEquirectangular(texture).texture;
                    hdrTexture = texture;

                    renderer.toneMapping = THREE.ACESFilmicToneMapping;
                    renderer.toneMappingExposure = this.data.exposure;
                    renderer.outputColorSpace = THREE.SRGBColorSpace;

                    applyEnvRotation(225, 180, 0);

                    threeScene.environment = envMap;
                    threeScene.background  = texture;

                    texture.dispose();
                    pmremGen.dispose();
                });
            }
        });*/

        const sceneEl = document.querySelector('a-scene');
        sceneEl.addEventListener('render-target-loaded', e => {
            const r = e.target.renderer;
            r.outputColorSpace = THREE.SRGBColorSpace;
            r.toneMapping = THREE.NeutralToneMapping;
            r.toneMappingExposure = 1.0;
        });
        sceneEl.addEventListener('loaded', () => {
            const r = sceneEl.renderer;
            r.shadowMap.enabled = true;
            r.shadowMap.type = THREE.PCFSoftShadowMap;
            r.toneMappingExposure = 1.3;

            const sun = document.querySelector('#sun').getObject3D('light');
            if (sun) {
                sun.shadow.mapSize.set(1024, 1024);
                sun.shadow.bias = -0.0005;
                sun.shadow.camera.near = 0.1;
                sun.shadow.camera.far  = 20;
                sun.shadow.camera.left = -5; sun.shadow.camera.right = 5;
                sun.shadow.camera.top = 5;  sun.shadow.camera.bottom = -5;
            }
        });

        function buildEnvFromHDRRotated(renderer, hdrTex, {yaw=0, pitch=0, roll=0} = {}) {
            const pmrem = new THREE.PMREMGenerator(renderer);
            const envScene = new THREE.Scene();
            const sky = new THREE.Mesh(
            new THREE.SphereGeometry(1, 64, 32),
            new THREE.MeshBasicMaterial({ map: hdrTex, side: THREE.BackSide, toneMapped: false })
            );
            sky.rotation.set(
            THREE.MathUtils.degToRad(pitch), // X
            THREE.MathUtils.degToRad(yaw),   // Y
            THREE.MathUtils.degToRad(roll)   // Z
            );
            envScene.add(sky);
            const { texture } = pmrem.fromScene(envScene, 0.0);
            pmrem.dispose();
            return texture;
        }

        const HDR_URL = './assets/hdri/spaichingen_hill_2k.hdr';
        const sky = document.querySelector("#hdr-skybox");

        sceneEl.addEventListener('loaded', () => {
            const renderer = sceneEl.renderer;
            new THREE.RGBELoader()
            .setDataType(THREE.UnsignedByteType)
            .load(HDR_URL, (tex) => {
                hdrTexture = tex;
                applyEnvRotation(225, 180, 0);
            });
        });

        function applyEnvRotation(yawDeg, pitchDeg, rollDeg){
            if (!hdrTexture) return;
            const renderer = sceneEl.renderer;
            const envMap = buildEnvFromHDRRotated(renderer, hdrTexture, {
            yaw: yawDeg, pitch: pitchDeg, roll: rollDeg
            });
            const threeScene = sceneEl.object3D;
            threeScene.environment = envMap;
            threeScene.background = envMap;
        }

    </script>
</html>